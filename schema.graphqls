# This schema file is temporary until other code is written. For the moment,
# this is the best place to make schema available during development, but
# eventually, this schema will need to be supplied by the codegen plugins that
# rely on it. _Hopefully_, I'll have better luck with `addToSchema` this time
# around.

"""
The JavaScript Date object as a database type
"""
scalar Date

"""
An arbitrary object used stored to the database. It will not be typesafe on its
own.
"""
scalar JSONObject

"""
CDC Event Types
"""
enum CdcEvent {
  INSERT
  MODIFY
  REMOVE
  UPSERT
}

"""
Supported DynamoDB Projection Types.
"""
enum ProjectionType {
  ALL
  KEYS_ONLY
}

"""
Configuration specific to a table dispatcher
"""
input DispatcherConfig {
  batchSize: Int
  maximumRetryAttempts: Int
  """
  Measured in megabytes.
  """
  memory: Int
  """
  Measured in seconds. Reminder that handlers may need to do retries in-band, so
  consider making this a relatively high number and using alarms to catch
  timeouts rather than terminating the function. In order to make space for up
  to 5 retries, please add sixty seconds to your intended timeout.
  """
  timeout: Int
}

"""
Configuration specific to a model handler
"""
input HandlerConfig {
  """
  Measured in megabytes.
  """
  memory: Int
  """
  Measured in seconds. Reminder that handlers may need to do retries in-band, so
  consider making this a relatively high number and using alarms to catch
  timeouts rather than terminating the function. In order to make space for up
  to 5 retries, please add sixty seconds to your intended timeout.
  """
  timeout: Int
}

"""
Changes the codegen output so that the model in question always uses consistent reads
"""
directive @consistent on OBJECT

"""
Computes the value of a field using the specified function.
"""
directive @computed(
  importName: String!
  importPath: String!
  """
  Virtual computed fields exist for the sole purposes of computing a complex
  value for use with an index field. The are not persisted to the database on
  their own.

  Ideally, they would be entirely hidden from the generated types, those types
  are generated by a third-party plugin. Long run, the solution is probably to
  write a schema loader that can transform the schema before it's passed to the
  TypeScript plugin.
  """
  virtual: Boolean
) on FIELD_DEFINITION

"""
Enriches the targetModel anytime there's a change to this model.
"""
directive @enriches(
  """
  Optional config to define the lambda parameters for the dispatcher and related
  resources
  """
  dispatcherConfig: DispatcherConfig
  """
  The type of change events to subscribe to.
  """
  event: CdcEvent!
  handlerImportName: String!
  """
  Path to the requireable package that handles a specific event. Relative paths
  are, unfortunately, relative to the _generated_ file, not the GraphQL schema
  file.
  """
  handlerPath: String!
  """
  Optional config to define the lambda parameters for the handler and related
  resources
  """
  handlerConfig: HandlerConfig
  """
  The model type that will be updated by this stream.
  """
  targetModel: String!
) repeatable on OBJECT

"""
Defines a Global Secondary Index
"""
directive @gsi(
  name: String!
  pkFields: [String!]!
  pkPrefix: String
  projectionType: ProjectionType
  skFields: [String!]
  skPrefix: String
) repeatable on OBJECT

"""
Indicates that this type is an append-only ledger and therefore create is the
only valid mutation
"""
directive @ledger on OBJECT

"""
Defines a Local Secondary Index
"""
directive @lsi(
  name: String!
  projectionType: ProjectionType
  skFields: [String!]
  skPrefix: String
) repeatable on OBJECT

"""
Indicates the the interface or type is backed by a DynamoDB table. Initially, we
relied on checking whether the target in question implemented Model to determine
if it was a table, but that doesn't work once we support interfaces. For
example, the `PublicModel` interface is _not_ a table, but implements `Model`,
so the parser didn't know what to do with it.

Long run, I'd like to remove most of the core interfaces (or, really, stop
requiring they be used directly) and instead attach them in the right spots
based on directives when the schema initially gets loaded.
"""
directive @model on OBJECT

"""
Defines the model's primary key
"""
directive @primaryKey(
  pkFields: [String!]!
  pkPrefix: String
  skFields: [String!]
  skPrefix: String
) on OBJECT

"""
Triggers the specified handler whenever there's a change to this model.
"""
directive @reacts(
  """
  Optional config to define the lambda parameters for the dispatcher and related
  resources
  """
  dispatcherConfig: DispatcherConfig
  """
  The type of change events to subscribe to.
  """
  event: CdcEvent!
  handlerImportName: String!
  """
  Path to the requireable package that handles a specific event. Relative paths
  are, unfortunately, relative to the _generated_ file, not the GraphQL schema
  file.
  """
  handlerPath: String!
  """
  Optional config to define the lambda parameters for the handler and related
  resources
  """
  handlerConfig: HandlerConfig
  """
  List of model names that this handler should be allowed to query. The
  CloudFormation resource will be updated accordingly.
  @experimental
  """
  readableModels: [String!]
  """
  List of model names that this handler should be allowed to write. The
  CloudFormation resource will be updated accordingly.
  @experimental
  """
  writableModels: [String!]
) repeatable on OBJECT

"""
Marks a single field as a Global Secondary Index.
"""
directive @simpleIndex(projectionType: ProjectionType) on FIELD_DEFINITION

# Only one of always or condition can be set. An error will be thrown if both
# are set.
input Condition {
  always: Boolean
  condition: String
}

"""
Allows customizing the generated attributes for a table.
"""
directive @table(
  """
  Defaults to true
  """
  enableEncryption: Condition
  """
  Defaults to true
  """
  enablePointInTimeRecovery: Condition
  """
  Allows overriding the generated table name for a Model. Generally, this is not
  recommended, but you might want to use this if you're migrating an existing
  set of tables to use this library.
  Defaults to the PascalCased name of the Model prefixed with Table
  """
  name: String
) on OBJECT

"""
Marks a field as the source for this model's ttl value. May only be declared once per model
"""
directive @ttl(
  """
  An ISO 8601 duration string. If no value is specified for the field, the expiration date will be now + this duration
  """
  duration: String
  """
  If duration is specified, codegen will not allow user to specify a value for expiration unless this is set to true.
  """
  overridable: Boolean
) on FIELD_DEFINITION

"""
Models are DynamoDB tables with a key schema that may or may not include a sort key. A Model must be decorated with either @partitionKey or @compositeKey.

Note that, while Model does not explicitly implement Node, its `id` field behaves like `Node#id` typically does. This is to avoid defining Node in the injected schema if the consumer's schema also defined Node or defines it differently.
"""
interface Model implements Timestamped & Versioned {
  createdAt: Date!
  id: ID!
  updatedAt: Date!
  version: Int!
}

"""
Like Model, but includes a `publicId` field which, unlike `id`, is semantically
meaningless. Types implementing PublicModel will have an additional function,
`queryByPublicId`, generated. If any of your models implement PublicModel, then
the dependencies module must include an `idGenerator()`.
"""
interface PublicModel implements Model & Timestamped & Versioned {
  createdAt: Date!
  id: ID!
  publicId: String!
  updatedAt: Date!
  version: Int!
}

"""
Automatically adds a createdAt and updatedAt timestamp to the entity and sets them appropriately. The createdAt timestamp is only set on create, while the updatedAt timestamp is set on create and update.
"""
interface Timestamped {
  """
  Set automatically when the item is first written
  """
  createdAt: Date!
  """
  Set automatically when the item is updated
  """
  updatedAt: Date!
}

"""
Automatically adds a column to enable optimistic locking. This field shouldn't be manipulated directly, but may need to be passed around by the runtime in order to make updates.
"""
interface Versioned {
  version: Int!
}
